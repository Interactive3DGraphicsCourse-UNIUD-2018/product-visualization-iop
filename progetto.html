<!DOCTYPE html>
<html>
<head>
    <title>Product visualization</title>
    <style>
            body{
                font-family: monospace;
                background-color: #222222;
                margin: 0px;
                overflow: hidden;
            }
    
            canvas{
                width: 100%;
                height: 100%;
            }
        </style>
        <script src="lib/three.min.js"></script>
        <script src="lib/stats.min.js"></script>
        <script src="lib/OrbitControls.js"></script>
        <script src="lib/dat.gui.min.js"></script>
        <script src="lib/GLTFLoader.js"></script>
        <script src="lib/Detector.js"></script>
</head>
<body>
    <!-- SHADERS -->
    <script type="text/x-glsl" id= "vertex">
        precision highp float;
        precision highp int;

        varying vec3 vNormal;
        varying vec3 vPosition;
        varying vec2 uVv;

        void main(){
            vec4 vPos = modelViewMatrix * vec4(position, 1.0);
            vPosition = vPos.xyz;
            vNormal = normalize(normalMatrix * normal);
            uVv = uv;
            gl_Position = projectionMatrix * vPos;
        }
    </script>

    <script type="text/x-glsl" id= "fragment">
        precision highp float;
        precision highp int;

        varying vec3 vNormal;
        varying vec3 vPosition;
        varying vec2 uVv;

        uniform vec3 pointLightPosition1;
        uniform vec3 pointLightPosition2;
        uniform vec3 clight1;
        uniform vec3 clight2;

        //uniform vec3 ambientLight;
        
        uniform sampler2D specularMap;
        uniform sampler2D diffuseMap;
        uniform sampler2D roughnessMap;
        uniform sampler2D normalMap;
        uniform sampler2D aoMap;
        uniform samplerCube envMap;

        uniform vec2 normalScale;
        uniform vec2 textureRepeat;      
        
        const float PI = 3.14159;

        vec3 cdiff;
        vec3 cspec;
        float roughness;

        #define saturate(a) clamp( a, 0.0, 1.0 )

        float pow2(const in float x) {
            return x*x;
        }
        float getSpecularMIPLevel(const in float blinnShininessExponent, const in int maxMIPLevel){
            float maxMIPLevelScalar = float(maxMIPLevel);
            float desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2(pow2(blinnShininessExponent) + 1.0);
            return clamp(desiredMIPLevel, 0.0, maxMIPLevelScalar);
        }
        float GGXRoughnessToBlinnExponent(const in float ggxRoughness){
            return (2.0 / pow2(ggxRoughness + 0.0001) - 2.0);
        }
        vec3 BRDF_Specular_GGX_Environment(vec3 normal, vec3 viewDir, const in vec3 cspec, const in float roughness){
            float NdotV = saturate(dot(normal, viewDir));
            const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);
            const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);
            vec4 r = roughness * c0 + c1;
            float a004 = min(r.x * r.x, exp2(-9.28 * NdotV)) * r.x + r.y;
            vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;
            return cspec * AB.x + AB.y;
        }

        vec3 FSchlick(float lDoth){
            return (cspec + (vec3(1.0) - cspec) * pow(1.0 - lDoth, 0.5));
        }

        float DGGX(float nDoth, float alfa){
            float alfa2 = alfa * alfa;
            float d = nDoth * nDoth * (alfa2 - 1.0) + 1.0;
            return (alfa2 / (PI * d * d));
        }

        float G1(float dotProduct, float k){
            return (dotProduct / (dotProduct * (1.0 - k) + k));
        }

        float GSmith(float nDotv, float nDotl){
            float k = roughness * roughness;
            return (G1(nDotl, k) * G1(nDotv, k));
        }

        vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {

			vec3 q0 = dFdx( eye_pos.xyz );
			vec3 q1 = dFdy( eye_pos.xyz );
			vec2 st0 = dFdx( uVv.st );
			vec2 st1 = dFdy( uVv.st );

			vec3 S = normalize(  q0 * st1.t - q1 * st0.t );
			vec3 T = normalize( -q0 * st1.s + q1 * st0.s );
			vec3 N =  surf_norm ;

			vec3 mapN = normalize(texture2D( normalMap, uVv ).xyz * 2.0 - 1.0);
			mapN.xy = normalScale * mapN.xy;
			mat3 tsn = mat3( S, T, N );
			return normalize( tsn * mapN );

        }
        
        vec3 inverseTransformDirection(in vec3 dir, in mat4 matrix){
            return normalize((vec4(dir, 0.0) * matrix).xyz);
        }
        
        void main(){

            cdiff = texture2D( diffuseMap, uVv*textureRepeat ).rgb;
            // texture in sRGB, linearize
            cdiff = pow( cdiff, vec3(2.2));
            cspec = texture2D( specularMap, uVv*textureRepeat ).rgb;
            // texture in sRGB, linearize
            cspec = pow( cspec, vec3(2.2));
            roughness = texture2D( roughnessMap, uVv*textureRepeat).r; 
            // no need to linearize roughness map

            vec3 n = perturbNormal2Arb( vPosition, normalize( vNormal ));

            vec3 v = normalize(-vPosition);
            float nDotv = max(dot(n, v), 0.000001);

            //light 1
            vec4 lPosition1 = viewMatrix * vec4(pointLightPosition1, 1.0);
            vec3 l1 = normalize(lPosition1.xyz - vPosition.xyz);
            vec3 h1 = normalize(v + l1);
            //small quantity to prevent division by 0
            float nDotl1 = max(dot(n, l1), 0.000001);
            float nDoth1 = max(dot(n, h1), 0.000001);
            float l1Doth1 = max(dot(l1, h1), 0.000001);
            float vDoth1 = max(dot(v, h1), 0.000001);
    
            vec3 fresnel1 = FSchlick(l1Doth1);
            vec3 specularBRDF1 = FSchlick(l1Doth1) * GSmith(nDotv, nDotl1) * DGGX(nDoth1, roughness*roughness) / (4.0 * nDotl1 * nDotv);
            vec3 diffuseBRDF1 = (vec3(1.0) - fresnel1) * cdiff/PI;
            vec3 BRDF1 = specularBRDF1 + diffuseBRDF1;
            vec3 outRadiance1 = PI * clight1 * nDotl1 * BRDF1;

            //light 2
            vec4 lPosition2 = viewMatrix * vec4(pointLightPosition2, 1.0);
            vec3 l2 = normalize(lPosition2.xyz - vPosition.xyz);
            vec3 h2 = normalize(v + l2);
            //small quantity to prevent division by 0
            float nDotl2 = max(dot(n, l2), 0.000001);
            float nDoth2 = max(dot(n, h2), 0.000001);
            float l2Doth2 = max(dot(l2, h2), 0.000001);
            float vDoth2 = max(dot(v, h2), 0.000001);
    
            vec3 fresnel2 = FSchlick(l2Doth2);
            vec3 specularBRDF2 = FSchlick(l2Doth2) * GSmith(nDotv, nDotl2) * DGGX(nDoth2, roughness*roughness) / (4.0 * nDotl2 * nDotv);
            vec3 diffuseBRDF2 = (vec3(1.0) - fresnel2) * cdiff/PI;
            vec3 BRDF2 = specularBRDF2 + diffuseBRDF2;
            vec3 outRadiance2 = PI * clight2 * nDotl2 * BRDF2;

            //Ambient Light
            vec3 vReflect = reflect(vPosition, n);
            vec3 r = inverseTransformDirection(vReflect, viewMatrix);
            float blinnShininessExponent = GGXRoughnessToBlinnExponent(roughness);
            float specularMIPLevel = getSpecularMIPLevel(blinnShininessExponent, 8);
            vec3 envLight = textureCubeLodEXT(envMap, vec3(-r.x, r.yz), specularMIPLevel).rgb;
            //texture in sRGB, linearize
            envLight = pow(envLight, vec3(2.2));
            vec3 outRadianceEnv = envLight * BRDF_Specular_GGX_Environment(n, v, cspec, roughness);

            //all lights
            vec3 outRadianceTOT = outRadiance1 + outRadiance2 + outRadianceEnv + (envLight * cdiff * texture2D(aoMap, uVv).xyz);
            // gamma encode
            gl_FragColor = vec4(pow(outRadianceTOT, vec3(1.0/2.2)), 1.0);
        }
    </script>

    <script>
        //DICHIARAZIONE VARIABILI
        var scene, camera, renderer, controls, stats, gui;
        var lightParameters1, lightParameters2, textureParameters, uniforms, clight;
        var diffuseMap, specularMap, roughnessMap, normalMap, aoMap, envMap;
        //var ambientLightParameters;

        function Start(){
            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.01, 1000);
            camera.position.set(0, 2, 5);
            scene.add(camera);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0xfefefe);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);
            window.addEventListener("resize", onWindowResize, false);

            //DEFINIZIONE DEGLI UNIFORMS
            lightParameters1 = {
                red: 1.0,
                green: 1.0,
                blue: 1.0,
                intensity: 1.0
            }

            lightParameters2 = {
                red: 1.0,
                green: 1.0,
                blue: 1.0,
                intensity: 1.0
            }

            // ambientLightParameters = {
            //     red: 0.2,
            //     green: 0.2,
            //     blue: 0.2,
            //     intensity: 1.0
            // }

            textureParameters = {
                material: "Wood_StaggeredFloorPlanks",
                repeatS: 1.0,
                repeatT: 1.0,
                normalScale: 1
            }

            diffuseMap = loadTexture("textures/materials/" + textureParameters.material + "_Diffuse.png");
            specularMap = loadTexture("textures/materials/" + textureParameters.material + "_Specular.png");
            roughnessMap = loadTexture("textures/materials/" + textureParameters.material + "_Roughness.png");
            normalMap = loadTexture("textures/materials/" + textureParameters.material + "_Normal.png");
            aoMap = loadTexture("textures/materials/" + textureParameters.material + "_Ambient_Occlusion.png");

            var cube_loader = new THREE.CubeTextureLoader();
            cube_loader.setPath("textures/cubemap/");   //fai cartelle interne per le diverse envmap
            var textureCube = cube_loader.load([
                'posx.png', 'negx.png',
                'posy.png', 'negy.png',
                'posz.png', 'negz.png'
            ]);
            //scelta del background
            scene.background = textureCube;
            textureCube.minFilter = THREE.LinearMipMapLinearFilter;

            uniforms = {
                specularMap: {type: "t", value: specularMap},
                diffuseMap: {type: "t", value: diffuseMap},
                roughnessMap: {type: "t", value: roughnessMap},
                envMap: {type: "t", value: textureCube},
                normalMap: {type: "t", value: normalMap},
                normalScale: {type: "v2", value: new THREE.Vector2(1,1)},
                aoMap: {type: "t", value: aoMap},
                //ambientLight: {type: "v3", value: new THREE.Vector3()},
                pointLightPosition1: {type: "v3", value: new THREE.Vector3()},
                pointLightPosition2: {type: "v3", value: new THREE.Vector3()},
                clight1: {type: "v3", value: new THREE.Vector3()},
                clight2: {type: "v3", value: new THREE.Vector3()},
                textureRepeat: {type: "v2", value: new THREE.Vector2(1,1)}
            }

            //DICHIARAZIONE DEGLI SHADERS
            vs = document.getElementById("vertex").textContent;
            fs = document.getElementById("fragment").textContent;

            //OGGETTI LUCI
            var lightGeometry = new THREE.SphereBufferGeometry(1, 16, 16);
            var lightMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00, wireframe: true});

            var lightMesh1 = new THREE.Mesh(lightGeometry, lightMaterial);
            lightMesh1.position.set(-10, -3, 10);
            uniforms.pointLightPosition1.value = new THREE.Vector3(lightMesh1.position.x, lightMesh1.position.y, lightMesh1.position.z);

            var lightMesh2 = new THREE.Mesh(lightGeometry, lightMaterial);
            lightMesh2.position.set(0, 10, -10);
            uniforms.pointLightPosition2.value = new THREE.Vector3(lightMesh2.position.x, lightMesh2.position.y, lightMesh2.position.z);

            //togliere per evitare di vedere i pallini gialli
            scene.add(lightMesh1);
            scene.add(lightMesh2);

            //OGGETTO PAVIMENTO //rivedere!!!
            var planeGeometry = new THREE.PlaneBufferGeometry(100, 100, 32);
            var planeMaterial = new THREE.MeshBasicMaterial({ color: 0xfefefe, side: THREE.DoubleSide });
            var plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.rotation.x = 90 * Math.PI / 180;
            plane.position.y = -2; 
            scene.add(plane);
            
            //DEFINIZIONE MATERIALI PERSONALIZZATI
            materialExtensions = {
                derivatives: true, //set to use derivatives
                shaderTextureLOD: true //set to use shader texture LOD
            }
            var ourMaterial = new THREE.ShaderMaterial( {uniforms: uniforms, vertexShader: vs, fragmentShader: fs, extensions: materialExtensions});
            ourMaterial.needUpdate = true;
 
            //LOADER MODELLO GLTF
            var loader = new THREE.GLTFLoader();
            loader.load('models/reattore arc v3/scene.gltf', function(gltf){
                // gltf.scene.traverse(function(child){
                //     if(child.isMesh){
                //         child.material = ourMaterial;
                //     }
                // });

                let path = gltf.scene;
                let indexChild = 0;
                //FARE UN CICLO FOR PER SCORRERE TUTTI I FIGLI E POI UNO SWITCH CASE PER I MATERIALI
                //PER IL SETTAGGIO AUTOMATICO DA GUI METTERE NEL UPDATE UNIFORM LA CHIAMATA A QUESTA FUNZIONE
                materialApply(path, ourMaterial, indexChild);
                scene.add(gltf.scene);
                gltf.scene.scale.multiplyScalar(1);
            });

            //CORREGGERE TEXTURE IN MODO CHE NON UTILIZZI QUELLE DEL MODELLO

            aoMap_total = loadTexture("textures/arc_reactor_Ambient Occlusion.png");
            normalMap_total = loadTexture("textures/arc_reactor_Normal Map.png");
            gltf.scene.overrideMaterial = //mettere shader con texture generali!!!

            //STATS
            stats = new Stats();
            stats.domElement.style.position = 'absolute';
            stats.domElement.style.top = '0px';
            document.body.appendChild(stats.domElement);

            //CONTROLS
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 0, 0);
            controls.minDistance = 1;
            controls.maxDistance = 100;
            controls.addEventListener('change', Render);
        }

        function Update(){
            requestAnimationFrame(Update);
            stats.update();
            Render();
        }

        function Render(){
            updateUniforms();
            renderer.render(scene, camera);
        }

        //FUNZIONE PER APPLICARE IL MATERIALE PASSATO AL FIGLIO SELEZIONATO
        function materialApply(obj, materialToApply, indexChild){
            while(!obj.children[0].isMesh){
            obj = obj.children[0];
            }
            obj = obj.parent;
            obj.children[indexChild].children[0].material = materialToApply;
        }

        //FUNZIONE LOADER TEXTURE
        function loadTexture(file){
            var texture = new THREE.TextureLoader().load(file, function(texture){
                texture.minFilter = THREE.LinearMipMapLinearFilter;
                texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
                texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                texture.offset.set(0, 0);
                texture.needUpdate = true;
                Render();
            });
            return texture;
        }

        //FUNZIONE ADATTAMENTO SCHERMO
        function onWindowResize(){
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = (window.innerWidth / window.innerHeight);
            camera.updateProjectionMatrix();
        }

        //FUNZIONI GESTIONE GUI
        function clearGUI(){
            if(gui){
                gui.destroy();
            }
            gui = new dat.GUI();
            gui.open();
        }

        function buildGUI(){
            clearGUI();
            lightSettings = gui.addFolder('Light Parameters 1');
            lightSettings.add(lightParameters1, 'red').min(0).max(1).onChange( function(newVal){ Render() });
            lightSettings.add(lightParameters1, 'green').min(0).max(1).onChange( function(newVal){ Render() });
            lightSettings.add(lightParameters1, 'blue').min(0).max(1).onChange( function(newVal){ Render() });
            lightSettings.add(lightParameters1, 'intensity').min(0).max(1).onChange( function(newVal){ Render() });

            lightSettings = gui.addFolder('Light Parameters 2');
            lightSettings.add(lightParameters2, 'red').min(0).max(1).onChange( function(newVal){ Render() });
            lightSettings.add(lightParameters2, 'green').min(0).max(1).onChange( function(newVal){ Render() });
            lightSettings.add(lightParameters2, 'blue').min(0).max(1).onChange( function(newVal){ Render() });
            lightSettings.add(lightParameters2, 'intensity').min(0).max(1).onChange( function(newVal){ Render() });

            // ambientLightSettings = gui.addFolder('Ambient Light Parameters');
            // ambientLightSettings.add(ambientLightParameters, 'red').min(0).max(1).onChange(function(newVal){ Render() });
            // ambientLightSettings.add(ambientLightParameters, 'green').min(0).max(1).onChange(function(newVal){ Render() });
            // ambientLightSettings.add(ambientLightParameters, 'blue').min(0).max(1).onChange(function(newVal){ Render() });
            // ambientLightSettings.add(ambientLightParameters, 'intensity').min(0).max(100).onChange(function(newVal){ Render() });

            textureSettings = gui.addFolder('Texture Parameters');
            textureSettings.add(textureParameters, 'material', ['Wood_StaggeredFloorPlanks', 'Misc_SolarPanelLarge', 'Concrete_RockyFoundation', 'Metal_ThickGrating']).onChange(function(newVal){
                diffuseMap = loadTexture("textures/materials/" + newVal + "_Diffuse.png");
                specularMap = loadTexture("textures/materials/" + newVal + "_Specular.png");
                roughnessMap = loadTexture("textures/materials/" + newVal + "_Roughness.png");
                normalMap = loadTexture("textures/materials/" + newVal + "_Normal.png");
                aoMap = loadTexture("textures/materials/" + newVal + "_Ambient_Occlusion.png");
                Render();
            });
            textureSettings.add(textureParameters, 'normalScale').min(-3).max(3).onChange(function(newVal){ Render() });
            textureSettings.add(textureParameters, 'repeatS').min(0.1).max(10).onChange(function(newVal){ Render() });
            textureSettings.add(textureParameters, 'repeatT').min(0.1).max(10).onChange(function(newVal){ Render() });
        }

        function updateUniforms(){
            uniforms.clight1.value = new THREE.Vector3(lightParameters1.red * lightParameters1.intensity, lightParameters1.green * lightParameters1.intensity, lightParameters1.blue * lightParameters1.intensity);
            uniforms.clight2.value = new THREE.Vector3(lightParameters2.red * lightParameters2.intensity, lightParameters2.green * lightParameters2.intensity, lightParameters2.blue * lightParameters2.intensity);
            uniforms.textureRepeat.value = new THREE.Vector2(textureParameters.repeatS, textureParameters.repeatT);
            uniforms.diffuseMap.value = diffuseMap;
            uniforms.specularMap.value = specularMap;
            uniforms.roughnessMap.value = roughnessMap;
            uniforms.normalMap.value = normalMap;
            uniforms.normalScale.value = new THREE.Vector2(textureParameters.normalScale, textureParameters.normalScale);
            uniforms.aoMap.value = aoMap;
            //uniforms.ambientLight.value = new THREE.Vector3(ambientLightParameters.red * ambientLightParameters.intensity, ambientLightParameters.green * ambientLightParameters.intensity, ambientLightParameters.blue * ambientLightParameters.intensity);
        }

        Start();
        buildGUI();
        Update();
        Render();
    </script>
</body>