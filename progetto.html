<!DOCTYPE html>
<html>
<head>
    <title>Product visualization</title>
    <style>
            body{
                font-family: monospace;
                background-color: #222222;
                margin: 0px;
                overflow: hidden;
            }
    
            canvas{
                width: 100%;
                height: 100%;
            }
        </style>
        <script src="lib/three.min.js"></script>
        <script src="lib/stats.min.js"></script>
        <script src="lib/OrbitControls.js"></script>
        <script src="lib/dat.gui.min.js"></script>
        <script src="lib/GLTFLoader.js"></script>
        <script src="lib/Detector.js"></script>
</head>
<body>
    <!-- SHADERS -->
    <script type="text/x-glsl" id= "vertex">
        varying vec3 vNormal;
        varying vec3 vPosition;
        varying vec2 uVv;

        void main(){
            vec4 vPos = modelViewMatrix * vec4(position, 1.0);
            vPosition = vPos.xyz;
            vNormal = normalMatrix * normal;
            uVv = uv;
            gl_Position = projectionMatrix * vPos;
        }
    </script>

    <script type="text/x-glsl" id= "fragment">
        varying vec3 vNormal;
        varying vec3 vPosition;
        varying vec2 uVv;

        uniform vec3 pointLightPosition1;
        uniform vec3 pointLightPosition2;
        uniform vec3 clight1;
        uniform vec3 clight2;

        uniform vec3 ambientLight;
        
        uniform sampler2D specularMap;
        uniform sampler2D diffuseMap;
        uniform sampler2D roughnessMap;
        uniform sampler2D normalMap;
        uniform sampler2D aoMap;

        uniform vec2 normalScale;
        uniform vec2 textureRepeat;

        const float PI = 3.14159;

        vec3 cdiff;
        vec3 cspec;
        float roughness;

        vec3 FSchlick(float lDoth){
            return (cspec + (vec3(1.0) - cspec) * pow(1.0 - lDoth, 0.5));
        }

        float DGGX(float nDoth, float alfa){
            float alfa2 = alfa * alfa;
            float d = nDoth * nDoth * (alfa2 - 1.0) + 1.0;
            return (alfa2 / (PI * d * d));
        }

        float G1(float dotProduct, float k){
            return (dotProduct / (dotProduct * (1.0 - k) + k));
        }

        float GSmith(float nDotv, float nDotl){
            float k = roughness * roughness;
            return (G1(nDotl, k) * G1(nDotv, k));
        }

        #extension GL_OES_standard_derivatives : enable

        vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {

			vec3 q0 = dFdx( eye_pos.xyz );
			vec3 q1 = dFdy( eye_pos.xyz );
			vec2 st0 = dFdx( uVv.st );
			vec2 st1 = dFdy( uVv.st );

			vec3 S = normalize(  q0 * st1.t - q1 * st0.t );
			vec3 T = normalize( -q0 * st1.s + q1 * st0.s );
			vec3 N =  surf_norm ;

			vec3 mapN = normalize(texture2D( normalMap, uVv ).xyz * 2.0 - 1.0);
			mapN.xy = normalScale * mapN.xy;
			mat3 tsn = mat3( S, T, N );
			return normalize( tsn * mapN );

		}
        
        void main(){

            cdiff = texture2D( diffuseMap, uVv*textureRepeat ).rgb;
            // texture in sRGB, linearize
            cdiff = pow( cdiff, vec3(2.2));
            cspec = texture2D( specularMap, uVv*textureRepeat ).rgb;
            // texture in sRGB, linearize
            cspec = pow( cspec, vec3(2.2));
            roughness = texture2D( roughnessMap, uVv*textureRepeat).r; 
            // no need to linearize roughness map

            vec3 n = perturbNormal2Arb( vPosition, normalize( vNormal ));

            vec3 v = normalize(-vPosition);
            float nDotv = max(dot(n, v), 0.000001);

            //light 1
            vec4 lPosition1 = viewMatrix * vec4(pointLightPosition1, 1.0);
            vec3 l1 = normalize(lPosition1.xyz - vPosition.xyz);
            vec3 h1 = normalize(v + l1);
            //small quantity to prevent division by 0
            float nDotl1 = max(dot(n, l1), 0.000001);
            float nDoth1 = max(dot(n, h1), 0.000001);
            float l1Doth1 = max(dot(l1, h1), 0.000001);
            float vDoth1 = max(dot(v, h1), 0.000001);
    
            vec3 fresnel1 = FSchlick(l1Doth1);
            vec3 specularBRDF1 = FSchlick(l1Doth1) * GSmith(nDotv, nDotl1) * DGGX(nDoth1, roughness*roughness) / (4.0 * nDotl1 * nDotv);
            vec3 diffuseBRDF1 = (vec3(1.0) - fresnel1) * cdiff/PI;
            vec3 BRDF1 = specularBRDF1 + diffuseBRDF1;
            vec3 outRadiance1 = PI * clight1 * nDotl1 * BRDF1;

            //light 2
            vec4 lPosition2 = viewMatrix * vec4(pointLightPosition2, 1.0);
            vec3 l2 = normalize(lPosition2.xyz - vPosition.xyz);
            vec3 h2 = normalize(v + l2);
            //small quantity to prevent division by 0
            float nDotl2 = max(dot(n, l2), 0.000001);
            float nDoth2 = max(dot(n, h2), 0.000001);
            float l2Doth2 = max(dot(l2, h2), 0.000001);
            float vDoth2 = max(dot(v, h2), 0.000001);
    
            vec3 fresnel2 = FSchlick(l2Doth2);
            vec3 specularBRDF2 = FSchlick(l2Doth2) * GSmith(nDotv, nDotl2) * DGGX(nDoth2, roughness*roughness) / (4.0 * nDotl2 * nDotv);
            vec3 diffuseBRDF2 = (vec3(1.0) - fresnel2) * cdiff/PI;
            vec3 BRDF2 = specularBRDF2 + diffuseBRDF2;
            vec3 outRadiance2 = PI * clight2 * nDotl2 * BRDF2;

            //all lights
            vec3 outRadianceTOT = outRadiance1 + outRadiance2 + (ambientLight * cdiff * texture2D(aoMap, uVv).xyz);
            // gamma encode
            gl_FragColor = vec4(pow(outRadianceTOT, vec3(1.0/2.2)), 1.0);
        }
    </script>

    <script>
        //DICHIARAZIONE VARIABILI
        var scene, camera, renderer, controls, stats, gui;
        var lightParameters1, lightParameters2, ambientLightParameters, textureParameters, uniforms, clight;
        var diffuseMap, specularMap, roughnessMap, normalMap;
        
        function Start(){
            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.01, 1000);
            camera.position.set(0, 0, 20);
            scene.add(camera);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x222222);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);
            window.addEventListener("resize", onWindowResize, false);

            //DEFINIZIONE DEGLI UNIFORMS
            lightParameters1 = {
                red: 1.0,
                green: 1.0,
                blue: 1.0,
                intensity: 1.0
            }

            lightParameters2 = {
                red: 1.0,
                green: 1.0,
                blue: 1.0,
                intensity: 1.0
            }

            ambientLightParameters = {
                red: 0.2,
                green: 0.2,
                blue: 0.2,
                intensity: 1.0
            }

            textureParameters = {
                material: "Wood_StaggeredFloorPlanks",
                repeatS: 1.0,
                repeatT: 1.0,
                normalScale: 1
            }

            diffuseMap = loadTexture("textures/" + textureParameters.material + "_Diffuse.png");
            specularMap = loadTexture("textures/" + textureParameters.material + "_Specular.png");
            roughnessMap = loadTexture("textures/" + textureParameters.material + "_Roughness.png");
            normalMap = loadTexture("textures/" + textureParameters.material + "_Normal.png");
            aoMap = loadTexture("textures/" + textureParameters.material + "_Ambient_Occlusion.png");

            uniforms = {
                specularMap: {type: "t", value: specularMap},
                diffuseMap: {type: "t", value: diffuseMap},
                roughnessMap: {type: "t", value: roughnessMap},
                normalMap: {type: "t", value: normalMap},
                normalScale: {type: "v2", value: new THREE.Vector2(1,1)},
                aoMap: {type: "t", value: aoMap},
                ambientLight: {type: "v3", value: new THREE.Vector3()},
                pointLightPosition1: {type: "v3", value: new THREE.Vector3()},
                pointLightPosition2: {type: "v3", value: new THREE.Vector3()},
                clight1: {type: "v3", value: new THREE.Vector3()},
                clight2: {type: "v3", value: new THREE.Vector3()},
                textureRepeat: {type: "v2", value: new THREE.Vector2(1,1)}
            }

            //DICHIARAZIONE DEGLI SHADERS
            vs = document.getElementById("vertex").textContent;
            fs = document.getElementById("fragment").textContent;

            //OGGETTI LUCI
            var lightGeometry = new THREE.SphereBufferGeometry(1, 16, 16);
            var lightMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00, wireframe: true});

            var lightMesh1 = new THREE.Mesh(lightGeometry, lightMaterial);
            lightMesh1.position.set(-10, -3, 10);
            uniforms.pointLightPosition1.value = new THREE.Vector3(lightMesh1.position.x, lightMesh1.position.y, lightMesh1.position.z);

            var lightMesh2 = new THREE.Mesh(lightGeometry, lightMaterial);
            lightMesh2.position.set(0, 10, -10);
            uniforms.pointLightPosition2.value = new THREE.Vector3(lightMesh2.position.x, lightMesh2.position.y, lightMesh2.position.z);

            scene.add(lightMesh1);
            scene.add(lightMesh2);
            
            //DEFINIZIONE MATERIALI PERSONALIZZATI
            var ourMaterial = new THREE.ShaderMaterial( {uniforms: uniforms, vertexShader: vs, fragmentShader: fs});
            ourMaterial.needUpdate = true;
 
            //LOADER MODELLO GLTF
            var loader = new THREE.GLTFLoader();
            loader.load('models/reattore arc v3/scene.gltf', function(gltf){
                gltf.scene.traverse(function(child){
                    if(child.isMesh){
                        child.material = ourMaterial;
                    }
                });
                scene.add(gltf.scene);
                gltf.scene.scale.multiplyScalar(1);
            });

            //STATS
            stats = new Stats();
            stats.domElement.style.position = 'absolute';
            stats.domElement.style.top = '0px';
            document.body.appendChild(stats.domElement);

            //CONTROLS
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 0, 0);
            controls.minDistance = 1;
            controls.maxDistance = 100;
            controls.addEventListener('change', Render);
        }

        function Update(){
            requestAnimationFrame(Update);
            stats.update();
            Render();
        }

        function Render(){
            updateUniforms();
            renderer.render(scene, camera);
        }

        //FUNZIONE LOADER TEXTURE
        function loadTexture(file){
            var texture = new THREE.TextureLoader().load(file, function(texture){
                texture.minFilter = THREE.LinearMipMapLinearFilter;
                texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
                texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                texture.offset.set(0, 0);
                texture.needUpdate = true;
                Render();
            });
            return texture;
        }

        //FUNZIONE ADATTAMENTO SCHERMO
        function onWindowResize(){
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = (window.innerWidth / window.innerHeight);
            camera.updateProjectionMatrix();
        }

        //FUNZIONI GESTIONE GUI
        function clearGUI(){
            if(gui){
                gui.destroy();
            }
            gui = new dat.GUI();
            gui.open();
        }

        function buildGUI(){
            clearGUI();
            lightSettings = gui.addFolder('Light Parameters 1');
            lightSettings.add(lightParameters1, 'red').min(0).max(1).onChange( function(newVal){ Render() });
            lightSettings.add(lightParameters1, 'green').min(0).max(1).onChange( function(newVal){ Render() });
            lightSettings.add(lightParameters1, 'blue').min(0).max(1).onChange( function(newVal){ Render() });
            lightSettings.add(lightParameters1, 'intensity').min(0).max(1).onChange( function(newVal){ Render() });

            lightSettings = gui.addFolder('Light Parameters 2');
            lightSettings.add(lightParameters2, 'red').min(0).max(1).onChange( function(newVal){ Render() });
            lightSettings.add(lightParameters2, 'green').min(0).max(1).onChange( function(newVal){ Render() });
            lightSettings.add(lightParameters2, 'blue').min(0).max(1).onChange( function(newVal){ Render() });
            lightSettings.add(lightParameters2, 'intensity').min(0).max(1).onChange( function(newVal){ Render() });

            ambientLightSettings = gui.addFolder('Ambient Light Parameters');
            ambientLightSettings.add(ambientLightParameters, 'red').min(0).max(1).onChange(function(newVal){ Render() });
            ambientLightSettings.add(ambientLightParameters, 'green').min(0).max(1).onChange(function(newVal){ Render() });
            ambientLightSettings.add(ambientLightParameters, 'blue').min(0).max(1).onChange(function(newVal){ Render() });
            ambientLightSettings.add(ambientLightParameters, 'intensity').min(0).max(100).onChange(function(newVal){ Render() });

            textureSettings = gui.addFolder('Texture Parameters');
            textureSettings.add(textureParameters, 'material', ['Wood_StaggeredFloorPlanks', 'Misc_SolarPanelLarge', 'Concrete_RockyFoundation', 'Metal_ThickGrating']).onChange(function(newVal){
                diffuseMap = loadTexture("textures/" + newVal + "_Diffuse.png");
                specularMap = loadTexture("textures/" + newVal + "_Specular.png");
                roughnessMap = loadTexture("textures/" + newVal + "_Roughness.png");
                normalMap = loadTexture("textures/" + newVal + "_Normal.png");
                aoMap = loadTexture("textures/" + newVal + "_Ambient_Occlusion.png");
                ourMaterial.needUpdate = true;
                Render();
            });
            textureSettings.add(textureParameters, 'normalScale').min(-3).max(3).onChange(function(newVal){ Render() });
            textureSettings.add(textureParameters, 'repeatS').min(0.1).max(10).onChange(function(newVal){ Render() });
            textureSettings.add(textureParameters, 'repeatT').min(0.1).max(10).onChange(function(newVal){ Render() });
        }

        function updateUniforms(){
            uniforms.clight1.value = new THREE.Vector3(lightParameters1.red * lightParameters1.intensity, lightParameters1.green * lightParameters1.intensity, lightParameters1.blue * lightParameters1.intensity);
            uniforms.clight2.value = new THREE.Vector3(lightParameters2.red * lightParameters2.intensity, lightParameters2.green * lightParameters2.intensity, lightParameters2.blue * lightParameters2.intensity);
            uniforms.textureRepeat.value = new THREE.Vector2(textureParameters.repeatS, textureParameters.repeatT);
            uniforms.diffuseMap.value = diffuseMap;
            uniforms.specularMap.value = specularMap;
            uniforms.roughnessMap.value = roughnessMap;
            uniforms.normalMap.value = normalMap;
            uniforms.normalScale.value = new THREE.Vector2(textureParameters.normalScale, textureParameters.normalScale);
            uniforms.aoMap.value = aoMap;
            uniforms.ambientLight.value = new THREE.Vector3(ambientLightParameters.red * ambientLightParameters.intensity, ambientLightParameters.green * ambientLightParameters.intensity, ambientLightParameters.blue * ambientLightParameters.intensity);
        }

        Start();
        buildGUI();
        Update();
        Render();
    </script>
</body>