<!DOCTYPE html>

<html lang="it">
    <head>
        <title>Reattore Ark - marlev.it</title>
        <link rel="stylesheet" href="index.css"/>
        
        <meta charset="UTF-8"/>
        <meta name="description" content="Acquista una replica di un reattore Ark personalizzabile su marlev.it"/>
        <meta name="author" content="Alessandro Iop"/>
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"/>
        
        <script src="lib/three.min.js"></script>
        <script src="lib/stats.min.js"></script>
        <script src="lib/OrbitControls.js"></script>
        <script src="lib/dat.gui.min.js"></script>
        <script src="lib/GLTFLoader.js"></script>
        <script src="lib/Detector.js"></script>
    </head>
    <body>
		<header>
			<a href="#"><img src="images/MarlevLogo.png"/></a>
		</header>
		<nav id="nav">
			<!-- menu -->
			<a href="#"><img src="images/noun_1686738_cc.svg">Home</a>
			<a href="#"><img src="images/noun_1686727_cc.svg">Carrello</a>
			<a href="#"><img src="images/noun_1686725_cc.svg">I prodotti</a>
			<div class="dropdown">
				<button class="dropbtn"><img src="images/noun_1686757_cc.svg">Area personale</button>
				<div class="dropdown-content">
					<a href="#">Log In / Sign In</a>
					<a href="#">Il mio account</a>
					<a href="#">I miei ordini</a>
					<a href="#">Privacy</a>
				</div>
			</div>
			
			<script type="text/javascript">                
				// When the user scrolls the page, execute myFunction
				window.onscroll = function() {
					myFunction()
				};
				
				var nav = document.getElementById("nav");
				var sticky = nav.offsetTop;

				// Add the sticky class to the header when you reach its scroll position. Remove "sticky" when you leave the scroll position
				function myFunction() {
					
					if (window.pageYOffset >= sticky) {
						nav.classList.add("sticky");
						document.getElementById("torna_su").classList.add("sticky_footer");
					} else {
						nav.classList.remove("sticky");
						document.getElementById("torna_su").classList.remove("sticky_footer");
					}                    
				} 
			</script>
		</nav>
			
		<div id="corpo">
			<h1>Reattore Ark replica in scala 1:1</h1>
			<h2>Memorabilia del film dell'Uomo di Ferro</h2><br>
			<p id="prezzo">PREZZO: 49,99&euro;</p>
			<button>
				Aggiungi al Carrello&nbsp;
				<img src="images/noun_1686727_cc.svg">
			</button>

			<!-- SHADERS -->
			<script type="text/x-glsl" id= "vertex">
				precision highp float;
				precision highp int;
		
				varying vec3 vNormal;
				varying vec3 vPosition;
				varying vec2 uVv;
		
				void main(){
					vec4 vPos = modelViewMatrix * vec4(position, 1.0);
					vPosition = vPos.xyz;
					vNormal = normalize(normalMatrix * normal);
					uVv = uv;
					gl_Position = projectionMatrix * vPos;
				}
			</script>
		
			<!-- shader con calcolo envMap -->
			<script type="text/x-glsl" id= "fragment">
				precision highp float;
				precision highp int;
		
				varying vec3 vNormal;
				varying vec3 vPosition;
				varying vec2 uVv;
		
				uniform vec3 pointLightPosition1;
				uniform vec3 pointLightPosition2;
				uniform vec3 clight1;
				uniform vec3 clight2;
				
				uniform sampler2D specularMap;
				uniform sampler2D diffuseMap;
				uniform sampler2D roughnessMap;
				uniform sampler2D normalMap;
				uniform sampler2D aoMap;
				uniform sampler2D aoMap_total;
				uniform samplerCube envMap;
		
				uniform vec2 normalScale;
				uniform vec2 textureRepeat;      
				
				const float PI = 3.14159;
		
				vec3 cdiff;
				vec3 cspec;
				float roughness;
		
				#define saturate(a) clamp( a, 0.0, 1.0 )
		
				float pow2(const in float x) {
					return x*x;
				}
				float getSpecularMIPLevel(const in float blinnShininessExponent, const in int maxMIPLevel){
					float maxMIPLevelScalar = float(maxMIPLevel);
					float desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2(pow2(blinnShininessExponent) + 1.0);
					return clamp(desiredMIPLevel, 0.0, maxMIPLevelScalar);
				}
				float GGXRoughnessToBlinnExponent(const in float ggxRoughness){
					return (2.0 / pow2(ggxRoughness + 0.0001) - 2.0);
				}
				vec3 BRDF_Specular_GGX_Environment(vec3 normal, vec3 viewDir, const in vec3 cspec, const in float roughness){
					float NdotV = saturate(dot(normal, viewDir));
					const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);
					const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);
					vec4 r = roughness * c0 + c1;
					float a004 = min(r.x * r.x, exp2(-9.28 * NdotV)) * r.x + r.y;
					vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;
					return cspec * AB.x + AB.y;
				}
		
				vec3 FSchlick(float lDoth){
					return (cspec + (vec3(1.0) - cspec) * pow(1.0 - lDoth, 0.5));
				}
		
				float DGGX(float nDoth, float alfa){
					float alfa2 = alfa * alfa;
					float d = nDoth * nDoth * (alfa2 - 1.0) + 1.0;
					return (alfa2 / (PI * d * d));
				}
		
				float G1(float dotProduct, float k){
					return (dotProduct / (dotProduct * (1.0 - k) + k));
				}
		
				float GSmith(float nDotv, float nDotl){
					float k = roughness * roughness;
					return (G1(nDotl, k) * G1(nDotv, k));
				}
		
				vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {
		
					vec3 q0 = dFdx( eye_pos.xyz );
					vec3 q1 = dFdy( eye_pos.xyz );
					vec2 st0 = dFdx( uVv.st );
					vec2 st1 = dFdy( uVv.st );
		
					vec3 S = normalize(  q0 * st1.t - q1 * st0.t );
					vec3 T = normalize( -q0 * st1.s + q1 * st0.s );
					vec3 N =  surf_norm ;
		
					vec3 mapN = normalize(texture2D( normalMap, uVv ).xyz * 2.0 - 1.0);
					mapN.xy = normalScale * mapN.xy;
					mat3 tsn = mat3( S, T, N );
					return normalize( tsn * mapN );
		
				}
				
				vec3 inverseTransformDirection(in vec3 dir, in mat4 matrix){
					return normalize((vec4(dir, 0.0) * matrix).xyz);
				}
				
				void main(){
		
					cdiff = texture2D( diffuseMap, uVv*textureRepeat ).rgb;
					// texture in sRGB, linearize
					cdiff = pow( cdiff, vec3(2.2));
					cspec = texture2D( specularMap, uVv*textureRepeat ).rgb;
					// texture in sRGB, linearize
					cspec = pow( cspec, vec3(2.2));
					roughness = texture2D( roughnessMap, uVv*textureRepeat).r; 
					// no need to linearize roughness map
		
					vec3 n = perturbNormal2Arb( vPosition, normalize( vNormal ));
		
					vec3 v = normalize(-vPosition);
					float nDotv = max(dot(n, v), 0.000001);
		
					//light 1
					vec4 lPosition1 = viewMatrix * vec4(pointLightPosition1, 1.0);
					vec3 l1 = normalize(lPosition1.xyz - vPosition.xyz);
					vec3 h1 = normalize(v + l1);
					//small quantity to prevent division by 0
					float nDotl1 = max(dot(n, l1), 0.000001);
					float nDoth1 = max(dot(n, h1), 0.000001);
					float l1Doth1 = max(dot(l1, h1), 0.000001);
					float vDoth1 = max(dot(v, h1), 0.000001);
			
					vec3 fresnel1 = FSchlick(l1Doth1);
					vec3 specularBRDF1 = FSchlick(l1Doth1) * GSmith(nDotv, nDotl1) * DGGX(nDoth1, roughness*roughness) / (4.0 * nDotl1 * nDotv);
					vec3 diffuseBRDF1 = (vec3(1.0) - fresnel1) * cdiff/PI;
					vec3 BRDF1 = specularBRDF1 + diffuseBRDF1;
					vec3 outRadiance1 = PI * clight1 * nDotl1 * BRDF1;
		
					//light 2
					vec4 lPosition2 = viewMatrix * vec4(pointLightPosition2, 1.0);
					vec3 l2 = normalize(lPosition2.xyz - vPosition.xyz);
					vec3 h2 = normalize(v + l2);
					//small quantity to prevent division by 0
					float nDotl2 = max(dot(n, l2), 0.000001);
					float nDoth2 = max(dot(n, h2), 0.000001);
					float l2Doth2 = max(dot(l2, h2), 0.000001);
					float vDoth2 = max(dot(v, h2), 0.000001);
			
					vec3 fresnel2 = FSchlick(l2Doth2);
					vec3 specularBRDF2 = FSchlick(l2Doth2) * GSmith(nDotv, nDotl2) * DGGX(nDoth2, roughness*roughness) / (4.0 * nDotl2 * nDotv);
					vec3 diffuseBRDF2 = (vec3(1.0) - fresnel2) * cdiff/PI;
					vec3 BRDF2 = specularBRDF2 + diffuseBRDF2;
					vec3 outRadiance2 = PI * clight2 * nDotl2 * BRDF2;
		
					//Ambient Light
					vec3 vReflect = reflect(vPosition, n);
					vec3 r = inverseTransformDirection(vReflect, viewMatrix);
					float blinnShininessExponent = GGXRoughnessToBlinnExponent(roughness);
					float specularMIPLevel = getSpecularMIPLevel(blinnShininessExponent, 8);
					vec3 envLight = textureCubeLodEXT(envMap, vec3(-r.x, r.yz), specularMIPLevel).rgb;
					//texture in sRGB, linearize
					envLight = pow(envLight, vec3(2.2));
					vec3 outRadianceEnv = envLight * BRDF_Specular_GGX_Environment(n, v, cspec, roughness);
		
					//all lights
					vec3 outRadianceTOT = outRadiance1 + outRadiance2 + outRadianceEnv + (envLight * cdiff * texture2D(aoMap, uVv).xyz) + (envLight * cdiff * texture2D(aoMap_total, uVv).xyz);
					// gamma encode
					gl_FragColor = vec4(pow(outRadianceTOT, vec3(1.0/2.2)), 1.0);
				}
			</script>
		
			<!-- shader con ambientLight e senza envMap -->
			<script type="text/x-glsl" id="fragment2">
				varying vec3 vNormal;
				varying vec3 vPosition;
				varying vec2 uVv;
		
				uniform vec3 pointLightPosition1;
				uniform vec3 pointLightPosition2;
				uniform vec3 clight1;
				uniform vec3 clight2;
		
				uniform vec3 ambientLight;
				
				uniform sampler2D specularMap;
				uniform sampler2D diffuseMap;
				uniform sampler2D roughnessMap;
				uniform sampler2D normalMap;
				uniform sampler2D aoMap;
				uniform sampler2D aoMap_total;
		
				uniform vec2 normalScale;
				uniform vec2 textureRepeat;      
				
				const float PI = 3.14159;
		
				vec3 cdiff;
				vec3 cspec;
				float roughness;
		
				vec3 FSchlick(float lDoth){
					return (cspec + (vec3(1.0) - cspec) * pow(1.0 - lDoth, 0.5));
				}
		
				float DGGX(float nDoth, float alfa){
					float alfa2 = alfa * alfa;
					float d = nDoth * nDoth * (alfa2 - 1.0) + 1.0;
					return (alfa2 / (PI * d * d));
				}
		
				float G1(float dotProduct, float k){
					return (dotProduct / (dotProduct * (1.0 - k) + k));
				}
		
				float GSmith(float nDotv, float nDotl){
					float k = roughness * roughness;
					return (G1(nDotl, k) * G1(nDotv, k));
				}
		
				vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {
		
					vec3 q0 = dFdx( eye_pos.xyz );
					vec3 q1 = dFdy( eye_pos.xyz );
					vec2 st0 = dFdx( uVv.st );
					vec2 st1 = dFdy( uVv.st );
		
					vec3 S = normalize(  q0 * st1.t - q1 * st0.t );
					vec3 T = normalize( -q0 * st1.s + q1 * st0.s );
					vec3 N =  surf_norm ;
		
					vec3 mapN = normalize(texture2D( normalMap, uVv ).xyz * 2.0 - 1.0);
					mapN.xy = normalScale * mapN.xy;
					mat3 tsn = mat3( S, T, N );
					return normalize( tsn * mapN );
		
				}
		
				void main(){
		
					cdiff = texture2D( diffuseMap, uVv*textureRepeat ).rgb;
					// texture in sRGB, linearize
					cdiff = pow( cdiff, vec3(2.2));
					cspec = texture2D( specularMap, uVv*textureRepeat ).rgb;
					// texture in sRGB, linearize
					cspec = pow( cspec, vec3(2.2));
					roughness = texture2D( roughnessMap, uVv*textureRepeat).r; 
					// no need to linearize roughness map
		
					vec3 n = perturbNormal2Arb( vPosition, normalize( vNormal ));
		
					vec3 v = normalize(-vPosition);
					float nDotv = max(dot(n, v), 0.000001);
		
					//light 1
					vec4 lPosition1 = viewMatrix * vec4(pointLightPosition1, 1.0);
					vec3 l1 = normalize(lPosition1.xyz - vPosition.xyz);
					vec3 h1 = normalize(v + l1);
					//small quantity to prevent division by 0
					float nDotl1 = max(dot(n, l1), 0.000001);
					float nDoth1 = max(dot(n, h1), 0.000001);
					float l1Doth1 = max(dot(l1, h1), 0.000001);
					float vDoth1 = max(dot(v, h1), 0.000001);
			
					vec3 fresnel1 = FSchlick(l1Doth1);
					vec3 specularBRDF1 = FSchlick(l1Doth1) * GSmith(nDotv, nDotl1) * DGGX(nDoth1, roughness*roughness) / (4.0 * nDotl1 * nDotv);
					vec3 diffuseBRDF1 = (vec3(1.0) - fresnel1) * cdiff/PI;
					vec3 BRDF1 = specularBRDF1 + diffuseBRDF1;
					vec3 outRadiance1 = PI * clight1 * nDotl1 * BRDF1;
		
					//light 2
					vec4 lPosition2 = viewMatrix * vec4(pointLightPosition2, 1.0);
					vec3 l2 = normalize(lPosition2.xyz - vPosition.xyz);
					vec3 h2 = normalize(v + l2);
					//small quantity to prevent division by 0
					float nDotl2 = max(dot(n, l2), 0.000001);
					float nDoth2 = max(dot(n, h2), 0.000001);
					float l2Doth2 = max(dot(l2, h2), 0.000001);
					float vDoth2 = max(dot(v, h2), 0.000001);
			
					vec3 fresnel2 = FSchlick(l2Doth2);
					vec3 specularBRDF2 = FSchlick(l2Doth2) * GSmith(nDotv, nDotl2) * DGGX(nDoth2, roughness*roughness) / (4.0 * nDotl2 * nDotv);
					vec3 diffuseBRDF2 = (vec3(1.0) - fresnel2) * cdiff/PI;
					vec3 BRDF2 = specularBRDF2 + diffuseBRDF2;
					vec3 outRadiance2 = PI * clight2 * nDotl2 * BRDF2;
		
					//all lights
					vec3 outRadianceTOT = outRadiance1 + outRadiance2 + (ambientLight * cdiff * texture2D(aoMap, uVv).xyz) + (ambientLight * cdiff * texture2D(aoMap_total, uVv).xyz);
					// gamma encode
					gl_FragColor = vec4(pow(outRadianceTOT, vec3(1.0/2.2)), 1.0);
				}
			</script>
		
			<!-- shader con envmap, con metalness e baseColor -->
			<script type="text/x-glsl" id="fragment-metalness">
				precision highp float;
				precision highp int;
		
				varying vec3 vNormal;
				varying vec3 vPosition;
				varying vec2 uVv;
		
				uniform vec3 pointLightPosition1;
				uniform vec3 pointLightPosition2;
				uniform vec3 clight1;
				uniform vec3 clight2;
				
				uniform sampler2D baseColorMap;
				uniform sampler2D roughnessMap;
				uniform sampler2D normalMap;
				uniform sampler2D metalnessMap;
				uniform sampler2D aoMap_total;
				uniform samplerCube envMap;
		
				uniform vec2 normalScale;
				uniform vec2 textureRepeat;  
				
				const float PI = 3.14159;
		
				vec3 cdiff;
				vec3 cspec;
				float roughness;
				float metalness;
				vec3 baseColor;
		
				#define saturate(a) clamp( a, 0.0, 1.0 )
		
				float pow2(const in float x) {
					return x*x;
				}
				float getSpecularMIPLevel(const in float blinnShininessExponent, const in int maxMIPLevel){
					float maxMIPLevelScalar = float(maxMIPLevel);
					float desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2(pow2(blinnShininessExponent) + 1.0);
					return clamp(desiredMIPLevel, 0.0, maxMIPLevelScalar);
				}
				float GGXRoughnessToBlinnExponent(const in float ggxRoughness){
					return (2.0 / pow2(ggxRoughness + 0.0001) - 2.0);
				}
				vec3 BRDF_Specular_GGX_Environment(vec3 normal, vec3 viewDir, const in vec3 cspec, const in float roughness){
					float NdotV = saturate(dot(normal, viewDir));
					const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);
					const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);
					vec4 r = roughness * c0 + c1;
					float a004 = min(r.x * r.x, exp2(-9.28 * NdotV)) * r.x + r.y;
					vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;
					return cspec * AB.x + AB.y;
				}
		
				vec3 FSchlick(float lDoth){
					return (cspec + (vec3(1.0) - cspec) * pow(1.0 - lDoth, 0.5));
				}
		
				float DGGX(float nDoth, float alfa){
					float alfa2 = alfa * alfa;
					float d = nDoth * nDoth * (alfa2 - 1.0) + 1.0;
					return (alfa2 / (PI * d * d));
				}
		
				float G1(float dotProduct, float k){
					return (dotProduct / (dotProduct * (1.0 - k) + k));
				}
		
				float GSmith(float nDotv, float nDotl){
					float k = roughness * roughness;
					return (G1(nDotl, k) * G1(nDotv, k));
				}
		
				vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {
		
					vec3 q0 = dFdx( eye_pos.xyz );
					vec3 q1 = dFdy( eye_pos.xyz );
					vec2 st0 = dFdx( uVv.st );
					vec2 st1 = dFdy( uVv.st );
		
					vec3 S = normalize(  q0 * st1.t - q1 * st0.t );
					vec3 T = normalize( -q0 * st1.s + q1 * st0.s );
					vec3 N =  surf_norm ;
		
					vec3 mapN = normalize(texture2D( normalMap, uVv ).xyz * 2.0 - 1.0);
					mapN.xy = normalScale * mapN.xy;
					mat3 tsn = mat3( S, T, N );
					return normalize( tsn * mapN );
		
				}
				
				vec3 inverseTransformDirection(in vec3 dir, in mat4 matrix){
					return normalize((vec4(dir, 0.0) * matrix).xyz);
				}
				
				void main(){
		
					metalness = texture2D(metalnessMap, uVv * textureRepeat).r;
					roughness = texture2D(roughnessMap, uVv * textureRepeat).r;
					baseColor = texture2D(baseColorMap, uVv * textureRepeat).rgb;
					baseColor = pow( baseColor, vec3(2.2));
		
					cspec = mix(vec3(0.04), baseColor, metalness);
					cdiff = mix(baseColor, vec3(0.0), metalness);
		
					vec3 n = perturbNormal2Arb( vPosition, normalize( vNormal ));
		
					vec3 v = normalize(-vPosition);
					float nDotv = max(dot(n, v), 0.000001);
		
					//light 1
					vec4 lPosition1 = viewMatrix * vec4(pointLightPosition1, 1.0);
					vec3 l1 = normalize(lPosition1.xyz - vPosition.xyz);
					vec3 h1 = normalize(v + l1);
					//small quantity to prevent division by 0
					float nDotl1 = max(dot(n, l1), 0.000001);
					float nDoth1 = max(dot(n, h1), 0.000001);
					float l1Doth1 = max(dot(l1, h1), 0.000001);
					float vDoth1 = max(dot(v, h1), 0.000001);
			
					vec3 fresnel1 = FSchlick(l1Doth1);
					vec3 specularBRDF1 = FSchlick(l1Doth1) * GSmith(nDotv, nDotl1) * DGGX(nDoth1, roughness*roughness) / (4.0 * nDotl1 * nDotv);
					vec3 diffuseBRDF1 = (vec3(1.0) - fresnel1) * cdiff/PI;
					vec3 BRDF1 = specularBRDF1 + diffuseBRDF1;
					vec3 outRadiance1 = PI * clight1 * nDotl1 * BRDF1;
		
					//light 2
					vec4 lPosition2 = viewMatrix * vec4(pointLightPosition2, 1.0);
					vec3 l2 = normalize(lPosition2.xyz - vPosition.xyz);
					vec3 h2 = normalize(v + l2);
					//small quantity to prevent division by 0
					float nDotl2 = max(dot(n, l2), 0.000001);
					float nDoth2 = max(dot(n, h2), 0.000001);
					float l2Doth2 = max(dot(l2, h2), 0.000001);
					float vDoth2 = max(dot(v, h2), 0.000001);
			
					vec3 fresnel2 = FSchlick(l2Doth2);
					vec3 specularBRDF2 = FSchlick(l2Doth2) * GSmith(nDotv, nDotl2) * DGGX(nDoth2, roughness*roughness) / (4.0 * nDotl2 * nDotv);
					vec3 diffuseBRDF2 = (vec3(1.0) - fresnel2) * cdiff/PI;
					vec3 BRDF2 = specularBRDF2 + diffuseBRDF2;
					vec3 outRadiance2 = PI * clight2 * nDotl2 * BRDF2;
		
					//Ambient Light
					vec3 vReflect = reflect(vPosition, n);
					vec3 r = inverseTransformDirection(vReflect, viewMatrix);
					float blinnShininessExponent = GGXRoughnessToBlinnExponent(roughness);
					float specularMIPLevel = getSpecularMIPLevel(blinnShininessExponent, 8);
					vec3 envLight = textureCubeLodEXT(envMap, vec3(-r.x, r.yz), specularMIPLevel).rgb;
					//texture in sRGB, linearize
					envLight = pow(envLight, vec3(2.2));
					vec3 outRadianceEnv = envLight * BRDF_Specular_GGX_Environment(n, v, cspec, roughness);
		
					//all lights
					vec3 outRadianceTOT = outRadiance1 + outRadiance2 + outRadianceEnv + (envLight * cdiff * texture2D(aoMap_total, uVv).xyz);
					// gamma encode
					gl_FragColor = vec4(pow(outRadianceTOT, vec3(1.0/2.2)), 1.0);
				}
			</script>
		
			<!-- shader con ambientLight e senza envMap, con metalness e baseColor -->
			<script type="text/x-glsl" id="fragment-metalness2">
				varying vec3 vNormal;
				varying vec3 vPosition;
				varying vec2 uVv;
		
				uniform vec3 pointLightPosition1;
				uniform vec3 pointLightPosition2;
				uniform vec3 clight1;
				uniform vec3 clight2;
		
				uniform vec3 ambientLight;
				
				uniform sampler2D baseColorMap;
				uniform sampler2D roughnessMap;
				uniform sampler2D normalMap;
				uniform sampler2D metalnessMap;
				uniform sampler2D aoMap_total;
		
				uniform vec2 normalScale;
				uniform vec2 textureRepeat;      
				
				const float PI = 3.14159;
		
				vec3 cdiff;
				vec3 cspec;
				float roughness;
				float metalness;
				vec3 baseColor;
		
				vec3 FSchlick(float lDoth){
					return (cspec + (vec3(1.0) - cspec) * pow(1.0 - lDoth, 0.5));
				}
		
				float DGGX(float nDoth, float alfa){
					float alfa2 = alfa * alfa;
					float d = nDoth * nDoth * (alfa2 - 1.0) + 1.0;
					return (alfa2 / (PI * d * d));
				}
		
				float G1(float dotProduct, float k){
					return (dotProduct / (dotProduct * (1.0 - k) + k));
				}
		
				float GSmith(float nDotv, float nDotl){
					float k = roughness * roughness;
					return (G1(nDotl, k) * G1(nDotv, k));
				}
		
				vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {
		
					vec3 q0 = dFdx( eye_pos.xyz );
					vec3 q1 = dFdy( eye_pos.xyz );
					vec2 st0 = dFdx( uVv.st );
					vec2 st1 = dFdy( uVv.st );
		
					vec3 S = normalize(  q0 * st1.t - q1 * st0.t );
					vec3 T = normalize( -q0 * st1.s + q1 * st0.s );
					vec3 N =  surf_norm ;
		
					vec3 mapN = normalize(texture2D( normalMap, uVv ).xyz * 2.0 - 1.0);
					mapN.xy = normalScale * mapN.xy;
					mat3 tsn = mat3( S, T, N );
					return normalize( tsn * mapN );
		
				}
		
				void main(){
		
					metalness = texture2D(metalnessMap, uVv * textureRepeat).r;
					roughness = texture2D(roughnessMap, uVv * textureRepeat).r;
					baseColor = texture2D(baseColorMap, uVv * textureRepeat).rgb;
					baseColor = pow( baseColor, vec3(2.2));
		
					cspec = mix(vec3(0.04), baseColor, metalness);
					cdiff = mix(baseColor, vec3(0.0), metalness);
		
					vec3 n = perturbNormal2Arb( vPosition, normalize( vNormal ));
		
					vec3 v = normalize(-vPosition);
					float nDotv = max(dot(n, v), 0.000001);
		
					//light 1
					vec4 lPosition1 = viewMatrix * vec4(pointLightPosition1, 1.0);
					vec3 l1 = normalize(lPosition1.xyz - vPosition.xyz);
					vec3 h1 = normalize(v + l1);
					//small quantity to prevent division by 0
					float nDotl1 = max(dot(n, l1), 0.000001);
					float nDoth1 = max(dot(n, h1), 0.000001);
					float l1Doth1 = max(dot(l1, h1), 0.000001);
					float vDoth1 = max(dot(v, h1), 0.000001);
			
					vec3 fresnel1 = FSchlick(l1Doth1);
					vec3 specularBRDF1 = FSchlick(l1Doth1) * GSmith(nDotv, nDotl1) * DGGX(nDoth1, roughness*roughness) / (4.0 * nDotl1 * nDotv);
					vec3 diffuseBRDF1 = (vec3(1.0) - fresnel1) * cdiff/PI;
					vec3 BRDF1 = specularBRDF1 + diffuseBRDF1;
					vec3 outRadiance1 = PI * clight1 * nDotl1 * BRDF1;
		
					//light 2
					vec4 lPosition2 = viewMatrix * vec4(pointLightPosition2, 1.0);
					vec3 l2 = normalize(lPosition2.xyz - vPosition.xyz);
					vec3 h2 = normalize(v + l2);
					//small quantity to prevent division by 0
					float nDotl2 = max(dot(n, l2), 0.000001);
					float nDoth2 = max(dot(n, h2), 0.000001);
					float l2Doth2 = max(dot(l2, h2), 0.000001);
					float vDoth2 = max(dot(v, h2), 0.000001);
			
					vec3 fresnel2 = FSchlick(l2Doth2);
					vec3 specularBRDF2 = FSchlick(l2Doth2) * GSmith(nDotv, nDotl2) * DGGX(nDoth2, roughness*roughness) / (4.0 * nDotl2 * nDotv);
					vec3 diffuseBRDF2 = (vec3(1.0) - fresnel2) * cdiff/PI;
					vec3 BRDF2 = specularBRDF2 + diffuseBRDF2;
					vec3 outRadiance2 = PI * clight2 * nDotl2 * BRDF2;
		
					//all lights
					vec3 outRadianceTOT = outRadiance1 + outRadiance2 + (ambientLight * cdiff * texture2D(aoMap_total, uVv).xyz);
					// gamma encode
					gl_FragColor = vec4(pow(outRadianceTOT, vec3(1.0/2.2)), 1.0);
				}
			</script>
		
			<script>
				//DICHIARAZIONE VARIABILI
				var scene, camera, renderer, controls, stats, gui;
				var lightParameters1, lightParameters2, textureParameters, uniforms, clight;
				var diffuseMap, specularMap, roughnessMap, normalMap, aoMap, envMap, metalnessMap, aoMap_total;
				var ambientLightParameters;
				var textureCube, env;
		
				function Start(){
					scene = new THREE.Scene();
		
					camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.01, 1000);
					camera.position.set(0, 2, 5);
					scene.add(camera);
		
					renderer = new THREE.WebGLRenderer({ antialias: true });
					if (window.innerWidth > 715) var size = 1/2;
					else var size = 9/10;
					renderer.setSize(window.innerWidth*size, window.innerHeight*size);
					renderer.setClearColor(0xfefefe);
					renderer.setPixelRatio(window.devicePixelRatio);
					document.getElementById("corpo").appendChild( renderer.domElement );
					window.addEventListener("resize", onWindowResize, false);
		
					//DEFINIZIONE DEGLI UNIFORMS
					lightParameters1 = {
						red: 1.0,
						green: 1.0,
						blue: 1.0,
						intensity: 1.0
					}
		
					lightParameters2 = {
						red: 1.0,
						green: 1.0,
						blue: 1.0,
						intensity: 1.0
					}
		
					ambientLightParameters = {
						red: 0.2,
						green: 0.2,
						blue: 0.2,
						intensity: 0.5
					}
		
					textureParameters = {
						material: "Basic_Steel",
						repeatS: 1.0,
						repeatT: 1.0,
						normalScale: 1,
						metalness: 1
					}
		
					roughnessMap = loadTexture("textures/materials/" + textureParameters.material + "/" + textureParameters.material + "_Roughness.png");
					normalMap = loadTexture("textures/materials/" + textureParameters.material + "/" + textureParameters.material + "_Normal.png");
		
					if(textureParameters.metalness == 0){
						diffuseMap = loadTexture("textures/materials/" + textureParameters.material + "/" + textureParameters.material + "_Diffuse.png");
						specularMap = loadTexture("textures/materials/" + textureParameters.material + "/" + textureParameters.material + "_Specular.png");
						aoMap = loadTexture("textures/materials/" + textureParameters.material + "/" + textureParameters.material + "_Ambient_Occlusion.png");
						baseColorMap = null;
						metalnessMap = null;
					} else if(textureParameters.metalness == 1){
						baseColorMap = loadTexture("textures/materials/" + textureParameters.material + "/" + textureParameters.material + "_Base_Color.png");
						metalnessMap = loadTexture("textures/materials/" + textureParameters.material + "/" + textureParameters.material + "_Metallic.png");
						diffuseMap = null;
						specularMap = null;
						aoMap = null;
					}
		
					aoMap_total = null;
					env = "appartamento";
					textureCube = loadEnv("textures/cubemap/" + env + "/");
		
					uniforms = {
						specularMap: {type: "t", value: specularMap},
						diffuseMap: {type: "t", value: diffuseMap},
						roughnessMap: {type: "t", value: roughnessMap},
						envMap: {type: "t", value: textureCube},
						normalMap: {type: "t", value: normalMap},
						normalScale: {type: "v2", value: new THREE.Vector2(1,1)},
						aoMap: {type: "t", value: aoMap},
						metalnessMap: {type: "t", value: metalnessMap},
						baseColorMap: {type: "t", value: baseColorMap},
						ambientLight: {type: "v3", value: new THREE.Vector3()},
						pointLightPosition1: {type: "v3", value: new THREE.Vector3()},
						pointLightPosition2: {type: "v3", value: new THREE.Vector3()},
						clight1: {type: "v3", value: new THREE.Vector3()},
						clight2: {type: "v3", value: new THREE.Vector3()},
						textureRepeat: {type: "v2", value: new THREE.Vector2(1,1)},
		
						aoMap_total: {type: "t", value: aoMap_total}
					}
		
					//DICHIARAZIONE DEGLI SHADERS
					vs = document.getElementById("vertex").textContent;
					fs = document.getElementById("fragment").textContent;
					fs2 = document.getElementById("fragment2").textContent;
					fs_metal = document.getElementById("fragment-metalness").textContent;
					fs_metal2 = document.getElementById("fragment-metalness2").textContent;
		
					//OGGETTI LUCI
					var lightGeometry = new THREE.SphereBufferGeometry(1, 16, 16);
					var lightMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00, wireframe: true});
		
					var lightMesh1 = new THREE.Mesh(lightGeometry, lightMaterial);
					lightMesh1.position.set(-10, 0, 3);
					uniforms.pointLightPosition1.value = new THREE.Vector3(lightMesh1.position.x, lightMesh1.position.y, lightMesh1.position.z);
		
					var lightMesh2 = new THREE.Mesh(lightGeometry, lightMaterial);
					lightMesh2.position.set(0, 10, 0);
					uniforms.pointLightPosition2.value = new THREE.Vector3(lightMesh2.position.x, lightMesh2.position.y, lightMesh2.position.z);
		
					//togliere per evitare di vedere i pallini gialli
					scene.add(lightMesh1);
					scene.add(lightMesh2);
		
					//parametri di default
					uniforms.clight1.value = new THREE.Vector3(lightParameters1.red * lightParameters1.intensity, lightParameters1.green * lightParameters1.intensity, lightParameters1.blue * lightParameters1.intensity);
					uniforms.clight2.value = new THREE.Vector3(lightParameters2.red * lightParameters2.intensity, lightParameters2.green * lightParameters2.intensity, lightParameters2.blue * lightParameters2.intensity);
					uniforms.ambientLight.value = new THREE.Vector3(ambientLightParameters.red * ambientLightParameters.intensity, ambientLightParameters.green * ambientLightParameters.intensity, ambientLightParameters.blue * ambientLightParameters.intensity);
					
					//DEFINIZIONE MATERIALI PERSONALIZZATI
					materialExtensions = {
						derivatives: true, //set to use derivatives
						shaderTextureLOD: true //set to use shader texture LOD
					}
					if(textureParameters.metalness == 0){
						var ourMaterial = new THREE.ShaderMaterial( {uniforms: uniforms, vertexShader: vs, fragmentShader: fs2, extensions: materialExtensions});
					} else {
						var ourMaterial = new THREE.ShaderMaterial( {uniforms: uniforms, vertexShader: vs, fragmentShader: fs_metal2, extensions: materialExtensions});
					}
		
					ourMaterial.needUpdate = true;
					ourMaterial.needsUpdate = true;
		 
					//LOADER MODELLO GLTF
					var loader = new THREE.GLTFLoader();
					loader.load('models/reattore arc v3/scene.gltf', function(gltf){
						let path = gltf.scene;
						for(let i = 0; i < 10; i++ ){
							if (i == 0 || i == 3 || i == 5 || i == 6 || i == 8 || i == 9) {
								materialApply(path, ourMaterial, i);        
							} else {
							}
						}
						scene.add(gltf.scene);
						gltf.scene.scale.multiplyScalar(1);
					});
		
					//STATS
					stats = new Stats();
					stats.domElement.style.position = 'absolute';
					stats.domElement.style.top = '0px';
					document.body.appendChild(stats.domElement);
		
					//CONTROLS
					controls = new THREE.OrbitControls(camera, renderer.domElement);
					controls.target.set(0, 0, 0);
					controls.minDistance = 1;
					controls.maxDistance = 100;
					controls.addEventListener('change', Render);
				}
		
				function Update(){
					requestAnimationFrame(Update);
					stats.update();
					Render();
				}
		
				function Render(){
					renderer.render(scene, camera);
				}
		
				function selectAO_total(indexChild){
					switch (indexChild) {
						case 0:
							uniforms.aoMap_total.value = loadTexture("textures/Ambient_Occlusions/Reactor_Front_Face_AO.jpeg");
							break;
						case 1:
							uniforms.aoMap_total.value = loadTexture("textures/Ambient_Occlusions/Reactor_Front_Glass_AO.jpeg");
							break;
						case 2:
							uniforms.aoMap_total.value = null;
							break;
						case 3:
							uniforms.aoMap_total.value = loadTexture("textures/Ambient_Occlusions/Reactor_Back_Face_AO.jpeg");
							break;
						case 4:
							uniforms.aoMap_total.value = loadTexture("textures/Ambient_Occlusions/Reactor_Glass_Inset_AO.jpeg");
							break;
						case 5:
							uniforms.aoMap_total.value = loadTexture("textures/Ambient_Occlusions/Reactor_Rear_Body_AO.jpeg");
							break;
						case 6:
							uniforms.aoMap_total.value = loadTexture("textures/Ambient_Occlusions/Reactor_Support_Structure_AO.jpeg");
							break;
						case 7:
							uniforms.aoMap_total.value = loadTexture("textures/Ambient_Occlusions/Light_Blocker_AO.jpeg");
							break;
						case 8:
							uniforms.aoMap_total.value = loadTexture("textures/Ambient_Occlusions/Stand_Main_Assembly_AO.jpeg");
							break;
						case 9:
							uniforms.aoMap_total.value = loadTexture("textures/Ambient_Occlusions/Stand_Base_AO.jpeg");
							break;  
						default:
							break;
					}
				}
		
				//FUNZIONE PER APPLICARE IL MATERIALE PASSATO AL FIGLIO SELEZIONATO
				function materialApply(obj, materialToApply, indexChild){
					selectAO_total(indexChild);
					while(!obj.children[0].isMesh){
					obj = obj.children[0];
					}
					obj = obj.parent;
					obj.children[indexChild].children[0].material = materialToApply;
				}
		
				//FUNZIONE LOADER TEXTURE
				function loadTexture(file){
					var texture = new THREE.TextureLoader().load(file, function(texture){
						texture.minFilter = THREE.LinearMipMapLinearFilter;
						texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
						texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
						texture.offset.set(0, 0);
						texture.needUpdate = true;
						Render();   //chiamare Update uniforms?
					});
					return texture;
				}
		
				//FUNZIONE COSTRUZIONE ENVIRONMENT MAP
				function loadEnv(dir){
					var cube_loader = new THREE.CubeTextureLoader().setPath(dir);
					textureEnv = cube_loader.load([
						'posx.png', 'negx.png',
						'posy.png', 'negy.png',
						'posz.png', 'negz.png'
					]);
					textureEnv.minFilter = THREE.LinearMipMapLinearFilter;
					Render();   //chiamare update uniforms?
					return textureEnv;
				}
		
				//FUNZIONE ADATTAMENTO SCHERMO
				function onWindowResize(){
					renderer.setSize(window.innerWidth, window.innerHeight);
					camera.aspect = (window.innerWidth / window.innerHeight);
					camera.updateProjectionMatrix();
				}
		
				function compare(string){
					if(string == "component"){
						return 0;
					} else if(string == "texture"){
						return 1;
					} else if(string == "lighting"){
						return 2;
					} else if(string == "sfondo"){
						return 3;
					}
				}
		
				function compareMaterial(string){
					if(string == "Basic_Steel"){
						return 1;
					} else if(string == "CarbonFiber"){
						return 1;
					} else if(string == "Malachite"){
						return 1;
					} else if(string == "rubberisedPlastic"){
						return 1;
					} else if(string == "Steel"){
						return 1;
					} else {
						return 0;
					}
				}
		
				function updateUniforms(arg1, arg2){
					switch (compare(arg1)) {
						case 0:
							materialApply(gltf.scene, ourMaterial, arg2);
							Render();
							break;
						case 1:
							if(compareMaterial(arg2) == 0){
								uniforms.diffuseMap.value = loadTexture("textures/materials/" + arg2 + "/" + arg2 + "_Diffuse.png");
								uniforms.specularMap.value = loadTexture("textures/materials/" + arg2 + "/" + arg2 + "_Specular.png");
								uniforms.roughnessMap.value = loadTexture("textures/materials/" + arg2 + "/" + arg2 + "_Roughness.png");
								uniforms.normalMap.value = loadTexture("textures/materials/" + arg2 + "/" + arg2 + "_Normal.png");
								uniforms.aoMap.value = loadTexture("textures/materials/" + arg2 + "/" + arg2 + "_Ambient_Occlusion.png");
								if(ourMaterial.fragmentShader == fs){
									ourMaterial.fragmentShader = fs;
								} else if(ourMaterial.fragmentShader == fs_metal){
									ourMaterial.fragmentShader = fs;
								} else {
									ourMaterial.fragmentShader = fs2;
								}
							} else if(compareMaterial(arg2) == 1){
								uniforms.roughnessMap.value = loadTexture("textures/materials/" + arg2 + "/" + arg2 + "_Roughness.png");
								uniforms.normalMap.value = loadTexture("textures/materials/" + arg2 + "/" + arg2 + "_Normal.png");
								uniforms.baseColorMap.value = loadTexture("textures/materials/" + arg2 + "/" + arg2 + "_Base_Color.png");
								uniforms.metalnessMap.value = loadTexture("textures/materials/" + arg2 + "/" + arg2 + "_Metallic.png");
								if(ourMaterial.fragmentShader == fs){
									ourMaterial.fragmentShader = fs_metal;
								} else if(ourMaterial.fragmentShader == fs_metal){
									ourMaterial.fragmentShader = fs_metal;
								} else {
									ourMaterial.fragmentShader = fs_metal2;
								}
							}
							Render();
							break;
						case 2:
							var light = arg2
							uniforms.clight1.value = new THREE.Vector3(light.r * 1.0, light.g * 1.0, light.b * 1.0);
							uniforms.clight1.value = new THREE.Vector3(light.r * 1.0, light.g * 1.0, light.b * 1.0);
							Render();
							break;
						case 3:
							if(arg2 == "bianco"){
								uniforms.ambientLight.value = new THREE.Vector3(0.2 * 0.5, 0.2 * 0.5, 0.2 * 0.5);
								if(ourMaterial.fragmentShader == fs){
									ourMaterial.fragmentShader = fs2;
								} else if(ourMaterial.fragmentShader == fs2){
									ourMaterial.fragmentShader = fs2;
								} else {
									ourMaterial.fragmentShader = fs_metal2;
								}
								scene.background = null;
							} else {
								textureCube = loadEnv("textures/cubemap/" + arg2 + "/");
								uniforms.envMap.value = textureCube;
								if(ourMaterial.fragmentShader == fs){
									ourMaterial.fragmentShader = fs;
								} else if(ourMaterial.fragmentShader == fs2){
									ourMaterial.fragmentShader = fs;
								} else {
									ourMaterial.fragmentShader = fs_metal;
								}
								scene.background = textureCube;
							}
							Render();
							break;
						default:
							Render();
							break;
					}
				}
		
				Start();
				Update();
		
				//trovare texture che funzionino bene
			</script>

			<!-- PERSONALIZZAZIONE DEL PRODOTTO -->
			<form>
				<fieldset>
					<legend>Texture del reattore</legend>
					<select>
						<option onchange="updateUniforms('component', 0)">Front face del reattore</option>
						<option onchange="updateUniforms('component', 3)">Back face del reattore</option>
						<option onchange="updateUniforms('component', 5)">Corpo posteriore del reattore</option>
						<option onchange="updateUniforms('component', 6)">Struttura di supporto del reattore</option>
						<option onchange="updateUniforms('component', 8)">Montatura del sostegno</option>
						<option onchange="updateUniforms('component', 9)">Base del sostegno</option>
					</select><br>
					<button type="button" onclick="updateUniforms('texture', 'rubberisedPlastic')">Plastica</button>
					<button type="button" onclick="updateUniforms('texture', 'metal_brushed_copper')">Rame</button>
					<button type="button" onclick="updateUniforms('texture', 'Basic_Steel')">Acciaio</button><br>
					<button type="button" onclick="updateUniforms('texture', 'Steel')">Acciaio Temperato</button>
					<button type="button" onclick="updateUniforms('texture', 'CarbonFiber')">Fibra di Carbonio</button>
					<button type="button" onclick="updateUniforms('texture', 'Malachite')">Malachite</button>
				</fieldset>

				<fieldset>
					<legend>Colore della luce</legend>
					<input type="radio" name="lighting" onclick="updateUniforms('lighting', new THREE.Vector3(1,1,1))" checked="checked">Bianco<br>
					<input type="radio" name="lighting" onclick="updateUniforms('lighting', new THREE.Vector3(1,0,0))">Rosso<br>
					<input type="radio" name="lighting" onclick="updateUniforms('lighting', new THREE.Vector3(0,1,0))">Verde<br>
					<input type="radio" name="lighting" onclick="updateUniforms('lighting', new THREE.Vector3(0,0,1))">Blu<br>
				</fieldset>

				<fieldset>
					<legend>Sfondo</legend>
					<button type="button"onclick="updateUniforms('sfondo', 'bianco')">Bianco</button>
					<button type="button" onclick="updateUniforms('sfondo', 'sala_ricreativa')">Sala ricreativa</button><br>
					<button type="button" onclick="updateUniforms('sfondo', 'sala_educativa')">Sala educativa</button>
					<button type="button" onclick="updateUniforms('sfondo', 'appartamento')">Appartamento</button>
				</fieldset>
			</form>

			<!-- DESCRIZIONE DEL PRODOTTO -->
			<br><br><p class="desc">Progettato da Howard Spark e successivamente adattato dal figlio Tony, il reattore Ark &egrave; un dispositivo costruito per alimentare le Spark Industries prima e la Spark Tower poi. Una sua versione miniaturizzata fu integrata dallo stesso Tony Spark nella sua celeberrima armatura dell'Uomo di Ferro, per alimentare inizialmente l'elettromagnete inserito nel suo petto (utile a mantenterlo in vita) oltre al suddetto esoscheletro e alle sue armi.</p>
			<p class="desc">La replica qui presentata riproduce fedelmente il reattore miniaturizzato visto nella saga cinematografica dei Vendicatori in scala 1:1, ed &egrave; dotata di un'elevata quantit&agrave; di dettagli nonch&eacute; di possibilit&agrave; di personalizzazione. Puoi scegliere infatti il materiale del prodotto, ma anche...</p>
		</div>

		<!-- FOOTER -->
        <footer>
			<a id="torna_su" href="#"><b>TORNA SU</b></a>
			<div id="footer_content">
				<h1>CONTATTACI:</h1>
				<address>
					Turus Davide: <a href="mailto:turus.davide@spes.uniud.it">turus.davide@spes.uniud.it</a><br/>
					Iop Alessandro: <a href="mailto:iop.alessandro@spes.uniud.it">iop.alessandro@spes.uniud.it</a>
				</address>
			</div>
			<p><a href="https://thenounproject.com/mikicon/collection/e-commerce-2/">Logos</a> created by mikicon from <a href="https://thenounproject.com/">the Noun Project</a></p>
        </footer>
    </body>
</html>